# RPC

&emsp;过程调用（函数调用）有本地过程调用和远程过程调用。  
* 本地过程调用：调用者和被调用者在同一个进程当中。  
* 远程过程调用：remote procedure call(RPC)，调用者和被调用者在不同的进程，称调用者为客户，被调用过程为服务器。

## 门

&emsp;门：提供一个进程调用同一台主机上另一个进程中的某个过程。  
* 文调用是同步的：调用者直到被调用过程返回后才能继续执行。（异步指，调用者和被调用者看起来在同时执行，比如主线程和子线程之间）  
* 客户请求远程调用时，服务器会分出一个线程处理客户请求，线程管理**通常**由门函数库负责。一个服务器进程可以打开多个服务器过程（也就是一个服务器程序可以接受客户对于多个函数的运程调用，方法是运行多个door_create和fattach）门函数库的线程池由所有的服务器过程共同使用。    
* 客户和服务器之间不仅可以传递数据，还可以传递描述符。因为门也是用描述符标识的，所以也可以传递门。  

### 涉及的函数

&emsp;服务器过程指的是，客户想要服务器执行的那个函数。  

door_create:服务器调用，用于根据服务器函数（客户想要执行的函数）创建一个门，它的返回值就是一个门描述符。虽然门用门描述符表示，但是当进程调用exec后描述符会关闭，而fork子进程时，子进程不能接收到客户的门激活（指的是引起一次服务器过程的运行）请求。有关门描述符的引用：door_create返回算一次，fattach调用也算一次，客户打开算一次；close(fd)减一次，fdetach路径名或rm路径名（可在命令行调用rm）都会减一次（二者只能减少一次）。当有一个客户请求时，门函数库会自动创建一个“脱离的”线程，禁止了线程取消功能。如果不想使用门函数库自动创建，可以通过do_server_create指定自己的服务器创建线程。  
fattach:用于将door_create返回的描述符和一个路径名联系起来。客户调用open打开这个路径名，从而获得门描述符。  
door_call:有客户调用，会在服务器进程的地址空间执行一个服务器进程。door_arg结构，是用来向服务器过程传递参数，描述符并容纳服务器过程返回值的结构体。如果调用者所给的返回值缓冲区过小，那么服务器会使用mmap创建一个缓冲区，而释放这个缓冲区是调用者的责任。服务器会将返回值中数据相关的放到door_arg中数据相关的指针中，描述符放在描述符相关的指针中，如果door_arg中结果缓冲区的大小足够，那么数据指针和结果指针的地址会在结果缓冲区内，否则服务器会分配缓冲区。    
door_return:服务器过程在完成工作时，通过调用door_return返回。  
door_cred:用于服务器过程获取客户凭证（有效用户和实际用户的用户ID和组ID，客户进程的PID）（有效用户在指定SUID时，不论实际运行程序的是哪一个用户，都会获得其属主的权限，这是有效用户就是其属主，实际用户就是其他用户）。  
door_info:用于获取服务器的相关信息，如PID等。  
door_server_create指定自己的服务器创建过程,其参数为创建线程的函数A，该函数的参数为door_info_t（一个结构体指针），由系统传递。A会创建一个线程，并将函数B作为线程启动函数。B函数的参数也是door_info_t，该函数需要用到fd，而该函数又会在创建fd的过程中被调用（初始时，系统会创建一个主线程，该线程也提供服务），所以使用同步，该函数还进行一些检查，并调用door_bind，禁止线程取消（根据需要而定）。  
door_bind:把调用线程捆绑到与某个门关联的私用服务器池。  
door_unbind:显式地把调用线程从其已绑定的门上松绑。  
door_revoke:撤销对于由fd表示的门的访问，一个门描述符只能由创建他的进程撤销，调用该函数时，已在进展中的任何门激活实例仍允许正常地完成。  

服务器过程不能够关闭打开的描述符，这一点可能需要厂商修改门的实现。
### 用于描述符传递

&emsp;这里的描述符不是一个int型的数值，也不是文件本身，可以理解为一个特定于内核的少量信息。描述符传递一定的内核技巧。使用门传递描述符，需要将描述符指针指向一个door_desc_t结构的指针。  
typedef struct door_desc{
    door_attr_t d_attrubutes;  //用来指明union中的结构是什么，由于只定义了一个结构体，所以该参数只能是DOOR_DESCRIPTOR
    union{
        struct {
            int d_descriptor;
            door_id_t d_id;
        }d_desc;    //该结构体用于描述一个描述符结构
    }d_data;
}door_desc_t;

服务器端：desc.d_data.d_desc.d_descriptor = fd;  
desc.d_attributes = DOOR_DESCRIPTOR;   进行设置传递&desc，作为返回值的描述符指针。

客户端：使用arg.desc_ptr->d_data.d_desc.d_descriptor 访问描述符。

#### 存在的问题

服务器过程不能够关闭打开的描述符，这一点可能需要厂商修改门的实现。


#### 运行出现异常

1、服务器提前终止，这会导致do_call返回一个EINTR错误。

2、do_call不可重新启动，因此必须阻塞调动do_call其间可能产生的任何信号，否则被中断后，do_call需要重新运行，不能从上次中断的位置重新开始，这样对于一个两次调用会导致结果不同的程序是不可以接收的，不以银行减去费用的程序（这种多次运行结果不同的程序是非等势的）。

3、如果在服务器返回之前，客户进程终止了。客户会向服务器线程发送一个取消请求。如果服务器禁止了取消功能，那就什么也不发生，线程继续执行，但是结果丢弃；如果启用了取消，那就调用所设置的清理程序，服务器线程随后终止。

## Sun RPC

区别于使用socket的显式网络编程，远程过程调用RPC称为隐式网络编程。RPC的目的是不需要显式的网络编程知识就允许编写分布式应用程序，其中套接字和网络I/O的所有细节，包括字节序都由**RPC运行时系统**来处理。

运行RPC服务器的任何主机必须在运行端口映射器,端口映射器的端口号是111，服务器向他登机自己的临时端口号。

1、名字以.x结尾的文件称为RPC说明书文件（RPC specification file），他们定义了服务器过程以及这些过程的参数和结果。使用**rpc_gen**一个随Sun RPC软件包提供的程序来编译这个说明书文件，将产生一个头文件（在编写客户主函数时，需要包含），客户程序存根（xxx_clnt.c）和一个xxx_xdr.c的文件用来处理XDR数据转换的文件。（XDR，external data representation 外部数据表示用来处理网络字节序等不同主机数据表示之间的差别），以及一个服务器主函数。

2、编写客户程序的主函数：clint_create根据服务器的域名或者IP，以及.x文件中相关的信息获取一个客户句柄（用于调用服务器过程）。远程调用的结果的结构是RPC运行时系统分配的，传入接收是我们手动分配的。

3、编写服务器过程，服务器的main函数是rpc_gen程序自动生成的。

集结：将客户提供的参数打包成一个网络消息的过程（marshaling)。

发送过程：  
客户程序->客户程序存根->RPC运行时函数库->系统调用网络通信->服务器端网络通信->服务器端RPC运行时库->服务器程序存根->服务器程序

返回过程：和发送过程反向。


### 服务器

服务器默认是使用迭代方式为客户提供服务的。通过给rpcgen指定-M或者-A让服务器提供多线程服务（并发服务）。

对于服务器分配的空间需要定义一个函数来释放它，释放函数需要定义成规范的名字，在服务器程序完成服务并返回结果后，在服务器程序的存根中调用。

可以使用inetd守护进程等待客户请求，通过一定的配置，当有客户请求到达时inetd或fork一个进程，然后通过exec执行服务器程序，对客户请求进行服务。服务器服务完后，还会停留一段时间，如果有新的客户请求到来，继续服务，以减少inetd的fork和exec开销，如果一段时间没有服务器终止，并通过SIGCHILD告知inetd，让inetd等待新的客户请求。

### 认证

RPC提供Unix认证，此时客户需要告诉RPC运行时系统随每个请求携带其身份信息（主机名，有效用户ID，有效组ID和可能多个辅助组ID）。

auth_destroy:销毁与句柄关联的先前的认证。  
auth_create_default:创建相应的UNIX认证结构。  

客户端创建一个Unix认证结构付给句柄的一个参数，服务器通过建设传入的结构进行相应的验证工作。

Unix认证很少使用，因为它极易被攻破。

RPC还支持其他形式的验证AUTH_SHORT，AUTO_DES是一种公钥私钥加密机制，AUTH——KERB基于MIT的kerberos认证系统。

### 超时和重传

总超时：客户等待其服务器应答的总时间量。TCP和UDP。

重试超时：客户在等待其服务器的应答其间每次重传请求的间隔时间。只用于UDP。

clnt_control：用于设置超时值等函数句柄的特性。类似于给一个描述符调用fcntl或者给一个套接字调用getsockopt或setsockopt。

clncreate函数将会创建一个tcp连接，这个tcp连接要么使用cln_destroy显式地终止，要么随着客户进程终止而隐式地终止。

RPC通过XID来确认服务器的应答，防止客户请求重复（重读请求检测需要打开重复请求高速缓存使用函数svc_dg_enablecache，一般用于UDP，TCP自己能处理重复请求）。

### 发生错误

服务器过早终止：当服务器进程终止时，会发送FIN分节给客户，此时客户程序返回错误。而如果服务于该客户的线程退出，那么由于TCP连接没有断开，所以不会发送FIN分节，此时要等到Timeout。对于UDP只能等到Timeout。

客户过早终止：服务器仍然运行到给客户发送应答，但是客户会回给服务器RST分节。


### XDR

XDR既是一种描述数据的语言，又是一组用于编码数据的规则。XDR可以独立于RPC软件包单独使用，其目的纯粹是为了以一种标准的格式交换数据。

所有数据类型的XDR表示都  
* 需要4的倍数的字节数  
* 这些字节总是以大端字节序传送  
* 带符号整数值使用二进制补码记法存放  
* 浮点数使用IEEE费事存放  
* 可变长度字段总是在其末端含有最多3个字节的填充，这样下一个条目总是落在某个4字节的边界。会在实际数据前面发送长度。

使用XDR传送数据以达到机器无关目的，需要使用XDR语言编写XDR说明文件，使用rpcgen可以解释XDR说明文件xxx.x，生成相应的C语言的头文件xxx.h以及xxx_xdr.c文件，其中xxx_xdr.c含有用于编码或解码在我们的xxx.x文件中所声明数据条目的XDR函数。

#### 单独使用XDR的步骤

先根据需要传送的数据在.x文件中定义相应的数据结构，然后运行rpcgen等程序解析.x文件，并在一个.c文件中设置想要传送数据的值，调用解析.x文件是产生的.c文件中的函数，对当前系统下的数据进行转换，得到XDR格式的数据，这些数据就是与系统无关的数据。

到达另一端，再调用相应的函数解析，从而完成传送。

* 关于设置XDR结构数据缓冲大小的设置：可以调用RNDUP逐个数据类型计算，对于结构体要分别计算各个成员然后加到一起；对于可变大小的就需要设置足够大的缓冲区，并检查XDR的失败情况。  
