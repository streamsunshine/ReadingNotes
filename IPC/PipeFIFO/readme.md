# Pipe&FIFO

&emsp;FIFO又称为有名管道（named pipe）。

&emsp;这里介绍管道和有名管道的使用。利用了客户-服务器的例子：客户读入一个路径名，传递给服务器，服务器打开该文件，并返回内容给客户，客户和服务器之间通信使用的就是IPC。

&emsp;管道和FIFO，在写的时候需要有另一个进程正在等待读取；二者具有进程持续性，当最后一次关闭发生时(维护一个描述符计数器)，管道和FIFO中的数据将被丢弃。

## 管道

&emsp;管道提供一个单向的数据流。创建时返回两个文件描述符，第一个用来读，第二个用来写，一般父进程保留写入端，子进程保留读出端，也就是对应着shell中的常见用法。  
&emsp;使用双向通信时需要在父进程创建两个管道。

&emsp;相关函数pipe（创建），read（读），write（写）。  
&emsp;管道相关的函数还有popen和pclose，两个函数用来和shell的命令配合工作。能够通过管道向shell命令传递参数，也可以通过管道接收shell命令的返回参数，取决于popen的实参。例程参见Popen.c。

**注**：描述符传递可以突破管道亲缘关系的限制。

## FIFO
&emsp;又称有名管道，每个FIFO与一个路径名关联，是一个单向的数据流，允许无亲缘关系的进程访问同一个FIFO。  
&emsp;相关函数：mkfifo创建一个FIFO，open或fopen打开一个已经存在的FIFO。read(读)，write（写）。

## 使用的注意事项

1、考虑阻塞模式还是不阻塞模式，二者对于open函数，read函数，write函数的返回值存在一定的差别。  
2、要处理read返回值小于所请求数目的情况。  
3、PIPE_BUF是posix的限制值，如果一次写入管道的数据小于等于这个那么可以保证原子性，否则不能保证。返回EAGAIN说明一点没写，否则返回写入的个数。因为是原子的（小于PIPE_BUF），所以可以多个进程打开写，不会造成所写数据交叉，同时也就不会在单进程读时(多进程读应该无法保证原子性)多个数据交叉。    
4、向一个没有读打开的管道或FIFO写入，内核会产生SIGPIPE（也就是说写入前需要有另外的进程正在等待读取数据），这个信号默认处理时终止进程，因此最好将其设置为忽略或者进行其他处理，此时write函数会返回EPIPE错误。  
5、一个技巧：在一个管道存在写打开（以写的模式打开）的时候，读该管道的read函数就不会返回0，这样可以让作为服务器的管道不关闭，从而一直等待客户连接。因此服务器处理读打开一个管道，还会写打开它，防止其从而让它阻塞在read中等待服务用户。  
6、读打开的open函数会阻塞，直到有一个写打开。写打开的也会阻塞，直到有一个读打开。对于一个管道不会死锁，但是两个及以上要考虑死锁问题。
7、FIFO不支持通过NFS在两个系统之间传递信息。  
8、**限制**：OPEN_MAX一个进程在任意时刻能够打开的最大描述符数。PIPE_BUF：可原子的写往一个管道或FIFO的最大数据量。  

## 程序编译及其ISSUE
&emsp;编译程序时，直接运行make，将会获得所有程序的可执行文件。
### Pipe.c
&emsp;程序参见了书上的例程。程序编译的时候使用了”进程间通信“的原书附带头文件，这样可以避免写很多相关的预编译头文件命令和一些必要的宏。

1、忘记回收子进程  
2、没有处理文件打开失败的情况  
3、忘记关闭文件描述符

### Popen.c
&emsp;该程序拷贝自原文例程。

### FifoServer.c And FifoClient.c

1、没有关闭描述符，也没有unlink创建的FIFO文件。先关闭描述符的目的是为了后面的unlink。由于程序结束后系统会回收描述符，所以服务器的不必操作描述符。unlink由客户程序进行是因为客户最后操作了fifo。
