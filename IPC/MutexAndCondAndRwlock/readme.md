# MutexAndCondAndRwlock
&emsp;关于互斥量，条件变量以及读写锁的说明和函数，在之前学习过一些内容，直接拿过来放到funcIntroduction文档中了，这里说明一些辅助性的问题以及在编程时间中的一些问题。  
&emsp;对于条件变量，如果在向条件变量发送信号时，没有线程等待在该条件变量上，该信号将丢失。  
&emsp;另外在“进程间通信”一书中，还是用了互斥量和条件变量对读写锁进行了实现，这个例子对于三者的理解很有益，希望能加以研究，同时书中对于线程在等待条件满足的过程中被取消的情况作了讨论，主要是用pthread_cleanup_push/pop进行清理，在编写其他程序时要特别注意持有锁的线程被取消的情况。

&emsp;对于进程间使用互斥锁，条件变量，要将它们存储在共享内存区中。在进程间共享互斥锁时，如果持有互斥锁的进程非自愿终止，是没有办法让系统自动释放进程所持有的锁的。我们可以假设进程可以清理，此时如果临界区进行了修改数据的操作，可能在修改一半的时候终止，这样如果进程清理了锁，就会导致不一致。  
&emsp;对于线程的情况，pthread_cancel用来取消一个线程，但是pthread_cleanup_push/pop可以设置取消一个线程时(进程自愿终止也会调用相应的函数)进行的清理操作。但是对于线程终止导致进程终止的情况，将向上面分析的一样。


&emsp;编程技巧：将共享数据和他们的同步变量(互斥锁,条件变量或信号量)收集到同一个结构中(如果共享数据是动态分配的,比如链表,就将链表的头和同步变量存放到一个结构中)。  
    编程原则：应该努力减少由一个互斥锁锁住的代码量。  
    注意：对于动态分配的变量要destroy。

## 生产者-消费者问题
&emsp;也称为有界缓冲区问题。生产者生产数据条目，消费者处理数据条目，数据条目在生产者和消费之之间使用某种形式的IPC传递。
&emsp;对于管道和消息队列，同步是隐式进行的，也就是由内核完成的。但是当使用共享内存区作为生产者和消费者之间的IPC形式时，就需要使用某种类型的显式同步。

