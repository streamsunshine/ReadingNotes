# Semaphore
&emsp;信号量支持进程间同步，也支持线程间同步。  
&emsp;我们将初始值为1的计数信号量称为二值信号量。实际上，通过sem_post二值信号量也可大于1，也就是信号的值不会受到初始化值的限制。  
&emsp;信号量存在三个操作：创建，等待，挂出（post）。

不同于互斥锁，信号量的挂出不必由执行过等待操作的同一线程/进程进行。  
不同于条件变量，信号量挂出时，即使没有线程在等待，也不会丢失。

用法：  
&emsp;信号量可作为当前可用资源的标志，从而控制生产者。同时定义另一个信号量作为当前占用资源的标志控制消费者。

## Posix信号量
&emsp;Posix信号量有两种：  
* 有名信号量：使用Posix IPC名字标识（参见../Readme.md）
* 基于内存的信号量：存放在共享内存区可以用于进程间的同步，存储在全局变量区的可以用来线程同步。

信号量的限制  
* SEM_NSEMS_MAX 一个进程可以同时打开的最大信号量数  
* SEM_VALUE_MAX 一个信号量的最大值  

### Posix有名信号量
&emsp;有名信号量既可以用于进程同步，又可以用于线程同步。只要给sem_open指定的名字相同，虽然不同进程返回的指针可能不同，但是访问的仍然是同一个信号量。如果父进程打开了有名信号量，那么子进程中可以直接使用。但是调用sen_unlink需要父子进程都调用，也可以在fork前调用，由于有名信号量的特性，信号量并不会立即删除。  
#### 涉及的函数
sem_open:使用Posix IPC名字，增加value用以指明信号量的初始值。返回值为sem_t类型。关于权限，信号量一般都要求读写权限，可能是因为等待和挂出都要对信号量进行修改。名字一般为有一个斜杠符的名字比如/test  
sem_close:关闭信号量。无论进程是自愿终止还是非自愿，进程终止时，内核对仍打开的有名信号量自动执行信号量关闭。信号量至少是内核持续的，关闭后它的值仍保持，直到被删除。  
sem_unlink：引用计数器open每打开一次增1，close每调用一次减一，名字也占据一个引用数，unlink可以用于减去这个引用数，当引用计数为0时，系统拆除。unlink可以在引用计数大于等于1的任意值时调用，此时也减一，如果减一后不为零，拆除将在close将引用计数减为0时发生。
    sem_wait,sem_trywait,sem_post  
sem_getvalue:对应的值如果为负数，其绝对值表示等待信号量解锁的线程数。

#### 特性
* 和记录锁不同，当持有某个信号量锁的进程没有释放它就终止时，内核并不给该信号量解锁。

### Posix基于内存的信号量

&emsp;基于内存的信号量：存放在共享内存区可以用于进程间的同步，存储在全局变量区的可以用来线程同步。由于Posix和System V的共享内存区具有内核持续性，所以对应的信号量有内核持续性，而对于放在全局变量区的信号量只具有进程持续性。

#### 涉及的函数
sem_init:进行信号量初始化，有一个指示进程间共享的标志位，如果进程间共享必须存储在共享内存区。该函数只能调用一次，调用两次的结果是未定义的，这和有名信号量是不同的。该函数成功并不返回0，失败返回-1.访问实际上是根据地址来的，所以不能拷贝sem_t进行访问。  
sem_destroy:用于信号量销毁，实际上对于存储在全局变量区的信号量系统会自动销毁。  
sem_wait,sem_trywait,sem_post,sem_getvalue,

## System V信号量

计数信号量集:一个或多个信号量（构成一个集合），其中每一个都是计数信号量。一般每个集合信号量数存在一个限制。  

&emsp;我们在谈论System V信号量是，指的是计数信号量集。每个信号量集，内核为其维护一个结构：  
struct semid_ds{
    struct ipc_perm sem_perm;   //指定信号量集的访问权限
    struct sem *sem_base;   //对应一个存储信号量信息的一个sem结构体数组
    ushort sem_nsems; //指定上面数组的大小，也就是信号量集中信号的数目
    time_t sem_otime; //上次操作信号集的时间
    time_t sem_ctime; //创建或者上次IPC_SET的时间
};

struct sem{
    ushort_t semval;    //信号量的值，非负的
    short sempid;   //上次成功操作信号量的进程ID
    ushort_t semncnt;   //等待其值增长的进程数
    ushort_t semzcnt;   //等待其值变为0的进程数
};

### 存在的一个缺陷
&emsp;System V的信号量初始化时分成两个步骤的，第一步调用semget初始化信号量集，此时信号量集中的信号的值是没有初始化的，第二步需要调用semctl初始化信号量的值。在这期间可能存在竞争，也就是可能有进程使用了没有初始化的信号量。  
&emsp;解决：由于semget初始化时置sem_otime值为零，并且只有在semop调用成功时才被设置为当前值。所以每个进程都先调用semget创建，如果该函数返回已经信号量已经创建，那么进程就获取信号量的标识符，然后检测sem_otime的值，并一直等待它的值不为零。这时信号量的初始化由第一个调用semget的进程执行，因为这个进程并不返回信号量已创建，所以不进入相应分支而是直接初始化信号量,并在调用semop后所有进程开始并发执行。  
&emsp;解决的代码参见RecordLockingSem.c中的例子代码。

### 涉及的函数

#### semget:
该函数传入key_t是由ftok根据路径名得到的，

返回值称为信号量标识符。创建好的不能改变信号量数。该函数值初始化semid_ds结构的成员，并不初始化信号量结构sem的成员，也就是说信号量的值是不保证的，  

semop:操作信号集中的信号量。每次函数调用可以进行多个操作，由一个数组指定（内核保证整个数组被原子执行，如果某一个操作返回错误，那么整个操作数组中的任何操作都不执行）。该数组中元素的顺序也是不保证的，所以不能用大括号初始化，只能逐个初始化。  
struct sembuf{
    short sem_num; //指定信号量集中的哪一个信号
    short sem_op;   
    short sem_flg;
};

#### sem_op:

正数，加到信号量值上释放资源。0表示调用之希望等待到信号量变成0；负数，希望等待信号量变为大于等于绝对值，如果等到了，返回时还将从信号量中减去绝对值。

sem_flg:IPC_NOWAIT,上面所说的等待都不等，直接返回EAGAIN错误；SEM_UNDO,指定的对于信号量值的操作会在进程终止后，和没有进行上述操作一样。


等待时进入睡眠的进程，如果被信号打断则返回EINTR错误（semop对应的是慢系统调用）。  
等待时，如果信号量被其他线程或进程删除，那么semop函数将返回EIDRM错误。

#### semctl:

可以用来获取信号量集的结构体中的信息；  
获取各个信号量值的信息；
设置信号量的值。  
删除信号量集  
. . . 
参考它的相应命令选项。

### 限制
* 系统范围最大信号量集数  
* 每个信号量集最大信号量数  
* 系统单位最大信号量数  
* 每个semop调用最大操作数  
* 系统范围最大复旧结构数  
* 每个复旧结构最大复旧项数  
* 信号量的最大值  
* 最大退出时调整值（设置SEM_UNDO时进程退出时，系统对信号量值做的调整）


## 程序

生产者和消费者问题  
&emsp;当前将缓冲区设置为环形缓冲区，因此要处理：
* 当缓冲区满时，生产者不能添加条目
* 当缓冲区空时，消费者不能去除条目



&emsp;使用信号量处理循环缓冲区很有优势，通过设置两个信号量，一个表示空位置数，一个表示已经占据的位置数，就可以分别控制生产者和消费者。在编写程序时要充分利用各种同步关系的优势。  
&emsp;将同步相关的量放置在同一个结构体往往方便观察。同时对于线程间同步，一般将这个结构体定义为全局变量。  
&emsp;编写程序要注意死锁的问题。  

SemProdCons1.c   
&emsp;这里是使用有名信号量编写的单生产者，单消费者程序。这里使用的是线程同步，实际上有名信号量也可用于进程同步。  
* 这里打来有名信号量的方式使用了O_EXCL参数，如果已经存在不会返回已有的值，这可能造成调试的困难，可以去掉该选项，程序运行不会受到影响。

SemMultiprodMulticons.c  
&emsp;是多生产者，多消费者的程序，这里使用了下面的基于内存的信号量，由于是线程同步，所以直接将同步变量存储在全局变量区。程序的问题有：  
* 当生产者程序结束后，最终的状态是semEmpty = NBUFF，而semStore = 0，这就导致消费者程序阻塞在等待semStore.因此需要在消费完所有生产者数据的时候，给阻塞的消费者程序提供semStore以结束自己。可以有两种方案，一种是我这里做的检测是否已经消费完，一种是在生产者结束时发送sem_post(&semStore)帮助消费者终止。

SemMultiBuff.c  
&emsp;该程序改编自SemProdCons1.c。测试了多缓冲区技术，程序功能是利用多缓冲区输入文件中读取数据，然后由另一个线程将多缓冲区中国的数据写到标准输出。这里面并没有用到二值信号量构建的临界区，实际上有些时候可以不用临界区从而提高并行度。

RecordLockingNone.c  
有关文件锁的叙述参照RecordLock一章，本程序使用不上锁的。

RecordLockingSem.c  
本程序使用System V信号量对文件进行上锁。这里的test.sh脚本可以用来测试程序，能够自动创建信号量的文件和seqfile文件，测试时可以直接运行该程序。

* 这里的SEM_UNDO还是比较重要的，可以消除每一个进程出现问题时，对其他进程的影响。

* do while循环终止条件应该为等于零，如果设置为不等于零，程序将会被投入到睡眠中，运行出现问题。
