# RecordLocking
&emsp;记录上锁，用于进程间共享某个文件的读与写。它不涉及到共享内存区，所以相比于进程间共享得互斥锁更有优势。实际上unix内核没有文件内的记录这一概念，这里的记录上锁是指应用可以指定文件中待上锁或解锁部分的字节范围，这和对整个文件上锁是有区别的。  
&emsp;**粒度和效率**：上锁的粒度越小，允许同时访问的用户就越多。比如一个文件可能不同进程访问的位置并不相同，如果支持对一部分上锁，就可以让多个进程同时操作文件。  

## 用途
1、常见用途是确保某个程序（如守护进程）在任何时刻只有一个副本在运行。  
2、文件做锁用。进程打开文件后尝试使用fcntl获取锁，获取锁的进程可以进行某些操作，而后获取的需要等待，从而利用文件实现了锁的功能。还可以用文件系统的特性实现文件做锁用。但最好的是fcntl。

## 涉及的函数
&emsp;fcntl用于记录上锁既可以读上锁，也可以写上锁。**注意**:1、一个文件中的任意字节最多只能存在一种**类型**的锁，对于读出锁可以有多个，写入锁只能有一个。2、对于一个不是打开读的描述符不能上读出锁，对于不是打开写的不能上写入锁。3、关闭描述符，或者进程终止与文件关联的所有锁都删除，fork的子进程不继承记录锁。4、记录锁不能和标准I/O库一起使用，该函数库会执行内部缓冲，为了避免上述问题应该使用read，write。  
&emsp;一些一同的实现当写请求和读请求同时存在时，会有一个优先级的问题，要加以考虑。  
&emsp;fcntl函数的详解参见../functionSys.md

## 劝告性上锁和强制性上锁

&emsp;Posix记录上锁是劝告性上锁（advisory locking），意思是即使一个进程锁定了一个文件，其余进程只要拥有相应的权限仍可以修改或读取对应文件。  
&emsp;强制性上锁，内核将会检查read和write请求，以验证其操作不会干扰由某个进程持有的某个锁，与强制性锁冲突的将会阻塞，对于非阻塞的read/write将会返回EAGAIN错误。  
&emsp;对特定文件使用强制性上锁，需要文件满足  
* 组成员执行位必须关闭
* SGID为必须打开
&emsp;对于支持强制性记录上锁的系统，通过ls -l指令通过l或L指示相应文件的强制性上锁是否启用。
&emsp;对于支持强制性上锁的系统，只需要修改需要强制性上锁文件的权限，其余操作和劝告性上锁相同，即可实现强制性上锁。
**注意**：强制性上锁也不能解决序号递增的问题，防止混乱的最好方法还是进程间进行协作。

## 程序和ISSUE
&emsp;这里的典型问题是序列号问题，进程读出共享文件中的序列号，将其增一后写回，涉及到的三个操作需要是原子操作，否则序列号将会是混乱的。本章主要是从这个问题出发进行讨论，将上锁和解锁函数通过不同的方式实现，从而解决问题。
&emsp;如何让多个进程并发执行，从而进行同步测试。  
    processname & processname &  
&emsp;这里编写了一个shell程序test，传入参数1对应两个有锁的程序运行，传入参数2对应两个无锁的程序，传入参数3一个有锁一个无锁用于测试劝告性上锁。

### 程序错误

* 打开文件读取内容会导致文件中的指针后移，如果一次打开要进行多次读取，需要使用lseek对文件指针进行定位。  
* flock结构不能使用大括号进行初始化，因为Posix只规定了结构（不仅仅flock结构）中的必要成员，并没有规定成员顺序，同时实现厂商可以增加自己的成员。
