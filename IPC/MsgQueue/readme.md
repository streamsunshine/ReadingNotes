# MsgQueue
&emsp;消息队列可以认为是一个消息链表。每个消息有优先级，长度（可以为0），数据三项。  
&emsp;与管道和FIFO不同，写入消息时，不需要有进程正在等待读取，也就是说消息队列是内核持续的。  
&emsp;Posix和System V之间的区别：System V支持返回任意指定优先级的消息，Posix总是返回最高优先级的最早消息;向空队列放置消息时，Posix允许产生一个信号或者启动一个线程，而System V不提供类似的机制。**关于第二个区别**：由于消息队列使用自己的标识符，而不是描述符（文件的，或者套接字的），所以不能使用select和poll进行新消息的通告，对于Posix由于有通知能力，可以使用单进程处理，而System V需要派生一个子进程，在子进程等待msgrcv返回，然后用管道通知主进程的select中的对应管道。

&emsp;新的应用应该考虑使用Posix消息队列。  
## Posix Message Queue 
**涉及的函数**:mq_open（相当于open）,mq_close,（相当于close，进程终止时系统会自动调用）,mq_unlink（用于删除消息队列对应的name,或称为拆除）
mq_get/setattr获取或者设置消息队列的属性。  
ma_send/receive用于消息的发送接收。
### 消息队列

消息队列描述符：用于描述一个消息队列，它很有可能不是一个短整数，可能是一个结构指针。

消息队列的创建：需要考虑路径名问题，权限问题（用户，组，其他），属性问题，模式问题（未创建怎么办，已创建怎么办）

消息队列的删除：消息队列为当前打开着的描述符维护一个引用计数器，mq_open每打开一次增1，mq_close每调用一次减一，但是消息队列的名字也占据一个引用数，mq_unlink可以用于减去这个引用数，当消息队列引用计数为0时，系统拆除消息队列。mq_unlink可以在引用计数大于等于1的任意值时调用，此时也减一，如果减一后不为零，拆除将在mq_close将引用计数减为0时发生。

消息队列的属性：mq_flags设置阻塞与否；mq_maxmsg设置消息队列中的最大消息数目；mq_msgsize一个消息的最大大小；mq_curmsgs队列中的当前消息数。

消息队列的限制：除了上面的属性限制和下面的优先级限制外，还有MQ_OPEN_MAX，一个进程能够同时拥有的打开着消息队列的最大数目。

### 消息

优先级：指定的优先级要小于MQ_PRIO_MAX。如果不需要指定优先级，发送函数指定为0，接收指定NULL。  
接收缓冲区：接收缓冲区要大于等于指定队列中的消息的最大大小，即ma_msgsize，否则接收函数直接返回错误。所以要先读消息队列属性，确定大小后分配缓冲区。  

## System V Message Queue
&emsp;这里消息队列使用消息队列标识符标识，内核为系统中的消息队列维护一个定义在<sys/msg.h>头文件中的信息结构msqid_ds，存储消息队列权限信息的ipc_perm结构就是msqid_ds的成员。

**相关函数**：msgget（创建新的消息队列或者访问一个已经存在的消息队列）。  
msgsnd消息的发送，可以指定非阻塞模式。可以构建自己的消息结构。注意：在发送消息时，指定长度指定的是不包含首部的long型的类型的字段的，但是缓冲区指定的地址需要从long型的类型字段开始。下面的msgrcv函数一样，同时msgrcv函数的返回值也是不包含首部的类型字段的。  
msgrcv消息的接收，可以指定接收消息的类型；缓冲区大小不必指定为消息的最大长度，小了会返回E2BIG，这个错误返回可以指定为不返回。可以指定为非阻塞。  
msgctl消息队列上的控制。IPC_RMID删除消息队列，丢弃其中的消息。IPC_SET设置msqid_ds中的成员。IPC_STAT获取msqid_ds结构。

### 消息队列的创建
&emsp;首先由路径名，由ftok（传递给ftok的路径必须是存在的）创建IPC键，msgget函数以IPC键或IP_PRIVATE为基础创建IPC标识符。标识符标识一个消息队列，标识符不特定于进程，而是特定于系统的，不同进程可以通过标识符访问消息队列。这里的标识符不用于Posix，是一个整数。

### 消息队列的删除以及属性
&emsp;都是通过msgctl函数实现的。

### 消息队列的限制
&emsp;每个消息的最大字节数限制；消息队列上的最大字节数限制；消息队列的最大消息数；系统中最大的消息队列数；  

### 阻塞返回

1、请求可以受理，这里包含传递传递为0的消息，对于EOF的处理就是通过发送一个长度为零的消息迫使msgrcv函数返回。 
2、对应消息队列被从系统中删除，此时返回EIDRM错误。  
3、调用线程被某个捕获的信号所中断，返回EINTR错误。 

### 注意事项
1、msgget并不是必须的，如果已知消息队列的标识符，并具有对这个消息队列的访问权限，那么就可以对消息队列进行操作。这种特性也适用于信号量和共享内存区。

## 程序以及ISSUE
&emsp;程序编写过程有一些错误，特别是关于创建消息队列描述符的时候，这里可以采用打印出errno的方法，观察一下出现的错误是什么，需要注意的是路径名必须事先创建好。另一个就是发送函数和接收函数，关于是否包含类型字段的问题，原则就是缓冲区地址需要包含，指定的长度不需要包含。  
&emsp;这里的程序使用了两个消息队列，实际上可以使用一个队列，客户端发送给服务器的消息类型为1，并在数据中包含自己的pid。服务器将pid读出，并作为返回消息的类型。这里不做实现。
