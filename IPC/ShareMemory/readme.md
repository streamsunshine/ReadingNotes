# ShareMemory
&emsp;共享内存区是可用IPC中最快的。在完成映射后，进程间的数据传递就不再涉及到内核（不需要使用系统调用来床底信息），也就是不在使用read，write等I/O操作，而是直接访问内存。

&emsp;默认情况下，通过fork派生的子进程并不与其父进程共享缓冲区。父子进程之间共享缓冲区的方法之一是，在调用fork之前，指定MAP_SHARED参数调用mmap。Posix保证父进程的内存映射关系保留到子进程。

## Posix共性内存区

### 文件映射内存区（内存映射文件）

&emsp;内存映射文件，是内存映射I/O的一种（内存映射I/O参见IPC/Readme，需要事先创建一个文件，然后打开文件，使用描述符进行映射。  

* 内存映射区和系统的页面：由于系统分配空间是按照页面分配的，所以一般页面占据的实际空间大于内存映射区实际需要的空间，对于由于页面分配的内部碎片多出来的这部分空间内存映射区读，读出来为0，但是不可以写，写会导致SIGSEGV信号。内存映射区分配页面的多少与mmap请求的有关，有文件大小无关。

* 内存映射区和文件大小的关系:设置内存映射区时允许指定大于文件大小，但是当访问到大于文件大小的区域时，将会返回SIGBUS信号。SIGBUS信号表示我们在内存映射去访问，但是超过了底层支持对象的大小。如果文件大小在不断变化，我们一般指定一个大的内存映射区，并且使用软件跟踪文件大小，确保访问在文件大小内，内核能够跟踪文件大小的变化，所以只要我们软件中跟踪了就不会发生SIGBUS错误。

### 匿名内存映射

&emsp;相比于文件映射内存去的好处是不用创建或指定具体的文件，在不需要文件参与的情况下，可以减少操作。

1、4.4BSD匿名内存映射的方法是：将mmap的flags参数指定成MAP_SHARED | MAP_ANON，把fd指定为-1，offset参数将被忽略。这样映射的内存区将被初始化0。

2、SVR4提供/dev/zero，open她后可以得到一个描述符，然后使用mmap进行映射。向/dev/zero写数据将被丢弃，从设备读数据将返回0，也就是共享内存区会被初始化为0，但是对于共享内存区的操作可以正常进行。

### 共享内存区对象

&emsp;共享内存区对象：有shm_open打开一个Posix.1名字或者打开一个已存在的共享内存区对象，由mmap把得到的描述符映射到当前进程地址空间。  
&emsp;同一共享内存区对象内存映射到不同进程的四肢空间是，起始地址可以不一样。

&emsp;内存映射文件和共享内存区对象合称为**内存区对象**。

#### 创建共享内存区对象的函数

&emsp;shm_open：用于根据Posix名字打开一个描述符。  打开的共享内存区对象大小是0.
shm_unlink：删除一个共享内存区对象的名字，删除名字并不影响其对于底层支撑对象的现有引用，直到对于该对象的引用全部关闭为止。  
ftruncate：用来调整普通文件或共享内存区对象的大小。但是对于普通文件修改大小并没有明确定义，普通文件修改大小：lseek移动到length-1处，然后写一个字节。对于共享内存区对象，该函数将其调整为指定大小。  而扩展部分的填充内容是不确定的。
fstat获取描述符对应对象的信息。对于共享内存区对象，可以返回用户ID，zuID，大小。


### 几种映射方法都会涉及的函数
mmap：将文件或共享内存区对象 映射到进程的内存区。  
munmap：删除映射关系。  
msync：手动同步映射区和文件，可以宝成同步确实已经进行。

## System V共享内存区

&emsp;内核为System V共享内存区维护的信息结构

struct shmid_s{
    struct ipc_perm shm_perm;   //共享内存区的访问权限
    size_t shm_segsz;   //分段大小
    pid_t shm_lpid;     //上次操作进程的pid
    pid_t shm_cpid;     //创建的pid
    shmatt_t shm_nattch;    //当前映射数目
    shmat_t shm_cnattch;    //当前在内存中的映射数目
    time_t shm_atime;       //上一次映射的时间
    time_t shm_dtime;       //上一次解除映射的时间
    time_t shm_ctime;       //上一次该结构体改变的时间
};

### 涉及的函数

需要注意的System V的信号量，共享内存，消息队列的函数接口规定，创建删除操作都是类似的，原理的大致 相同。

shmget：创建一个新的共享内存区，或者访问一个已经存在的共享内存区。使用的ftok返回的键值或者IPC_PRIVATE。返回值是共享内存区标识符。创建新缓冲区时内存区被初始化为零。  
shmat：将shmget的共享内存区附到调用进程的地址空间。  
shmdt：断接内存区，当进程终止时，附接着的所有内存区都会自动断接掉。**断接**并不是删除共享内存区，是将其引用计数减一。  
shmctl：IPC_RMID：删除共享内存区并拆除它。删除：是指标识符失效，以后针对该标识符的操作都失败。拆除：指删除数据结构，但是要等到引用计数为0时进行。 IPC_SET：设置shmid_ds的某些成员。 IPC_STAT：查询shmid_ds。

### 共享内存区限制

* 共享内存区的最大字节数  
* 共享内存区的最小字节数  
* 系统范围内最大共享内存区标识符数  
* 每个进程附接的最大共享内存区数  

## 程序

### 文件映射内存区例程

程序AddOnePosixNameSem.c和AddOnePosixMemSem.c是分别使用Posix有名信号量和基于内存的信号量，使用的就是文件映射的方法，实现了序号好问题的进程间同步。由于这里面最终写入到seqfile文件的是int型数据的，所以使用vim 打开可能看不到正确的计数值，可以使用 od -D seqfile 命令查看。

### 共享内存区对象例程

在编写程序的时候要注意处理描述符，对于打开的描述符尽量关闭，不去依赖于系统的自动清理。

要区分close和unlink的区别。close后底层对象依然存在，所以使用shm_open的时候会显示存在，但是如果unlink后，那么底层对象就不存在了，新的进程可以需要重新创建，而重新创建的将不再与之前存在的相关。由于这个原因，尝试使用一个进程实现功能失败了，这里面使用的是一个服务器和多个客户，先运行服务器，然后可以运行多个客户，通过给test传入参数1进行测试。

* shm_open显示undefined，在makefile中添加 -lrt。

### 其他例程

&emsp;书中还有一个关于服务器做消费者，客户做生产者的稍微复杂一些的程序，涉及的特性更多一些，更能体现并发编程的思想，可以研究这里不进行重新编写。
